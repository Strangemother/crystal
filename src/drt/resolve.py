import logic
from drs import *


class ConsistencyError(Exception): pass
class ResolutionError(ConsistencyError): pass
class AccommodationError(ResolutionError): pass


def Resolve(drs, context, is_question):
  # Questions are not added to the context as facts.
  if is_question:
    drs = drs.Copy()
  else:
    drs = (context or DRS()) + drs
    
  # Eliminate repeated named referents.
  drs.RaiseNamedRefs()
  
  # Remove presuppositions resolved by existing equalities (e.g. generated by
  # verb to be).
  ResolveEqualities(drs)

  const_context = context if is_question else None
  
  # Bind presuppositions as possible.
  ResolveAnaphora(drs, const_context, accommodate=False, pronouns=False)
  
  # Accommodate presuppositions that could not have been bound. This might
  # create new referents for pronouns.
  ResolveAnaphora(drs, const_context, accommodate=True, pronouns=False)
  
  # Bind all pronouns.
  ResolveAnaphora(drs, const_context, accommodate=False, pronouns=True)

  # Apply all equation conditions.
  drs.Simplify()

  # Remove referents known to the context.
  if is_question:
    for ref in drs.referents.copy():
      if ref in context.referents or isinstance(ref, NamedReferent):
        drs.referents.remove(ref)
  
  return drs


def ResolveAnaphora(drs, const_context, accommodate, pronouns):
  for cond in drs.conditions:
    for subdrs in cond.GetChildDRSs():
      ResolveAnaphora(subdrs, const_context, accommodate, pronouns)

    if isinstance(cond, ResolutionCondition):
      if not pronouns and cond.type.startswith('pronoun-'):
        continue
      drs.RemoveCondition(cond)
      target = ResolveCondition(cond, const_context)
##      print 'Resolving', cond
      if target:
        target_ref, target_drs = target
        outermost = drs
        if not const_context:
          target_drs += cond.requirements
          while outermost.parent:
            outermost = outermost.parent
          assert isinstance(outermost, DRS)
##        print 'Replacing', cond.ref, 'with', target_ref, 'in', outermost.summary
        outermost.ReplaceReferent(cond.ref, target_ref, add_new=True)
##        print 'Result', outermost.summary
      elif accommodate:
##        print 'Accomodating'
        if const_context:
          raise AccommodationError('Accommodation requested in const context.')
          
        accommodating_drs = DRS([cond.ref]) + cond.requirements
        accomodated = False
        ancestors = [drs]
        temp = drs
        while temp.parent:
          temp = temp.parent.parent
          ancestors.append(temp)
        for potential_drs in reversed(ancestors):
          temp_drs = potential_drs.Copy()
          temp_drs += accommodating_drs
          temp_drs.EliminateResolutions()
          temp_drs.Simplify()
          if logic.IsConsistent(temp_drs):
##            print potential_drs.summary, '+=', temp_drs.summary
            potential_drs += accommodating_drs
            accomodated = True
            break
        if not accomodated:
          raise ResolutionError('Could not accommodate anaphor.', cond)
      else:
        drs.AddCondition(cond)


def ResolveCondition(cond, context_drs=None):
  ref, requirements = cond.ref, cond.requirements
  assert not isinstance(ref, NamedReferent)

  accessible_refs = requirements.parent.GetAccessibleReferents().items()
  accessible_refs.reverse()
  if context_drs:
    extra_refs = list(reversed(context_drs.GetAccessibleReferents().items()))
    accessible_refs = accessible_refs + extra_refs
  test = IsProvable if cond.type == 'presuppose' else IsConsistent

  for target, base_drs in accessible_refs:
    if not AreRefsCompatible(target, ref):
      continue
    if test(ref, target, base_drs, requirements):
      return target, base_drs

  if cond.type.startswith('pronoun-'):
    raise ResolutionError('Could not resolve anaphor.', cond)


def AreRefsCompatible(target, ref):
  return (target != ref and
          (target.type == ref.type or
           ref.type == SINGULAR_TYPE and target.type == PLURAL_TYPE))


def IsConsistent(ref, target, base_drs, requirements):
  assert not isinstance(ref, NamedReferent)
##  print 'Validating', ref, '=', target
  temp_drs = base_drs + requirements
  temp_drs.EliminateResolutions()
  temp_drs.Simplify()
  temp_drs.ReplaceReferent(ref, target, add_new=True)
  return logic.IsConsistent(temp_drs)


def IsProvable(ref, target, base_drs, requirements):
  assert not isinstance(ref, NamedReferent)
##  print 'Proving', ref, '=', target
##  print '  IF ', base_drs
##  print '  THEN ', requirements
  temp_base = base_drs.Copy()
  temp_base.EliminateResolutions()
##  print '  IF2 ', temp_base
  temp_base.Simplify()
##  print '  IF3 ', temp_base
  temp_base.ReplaceReferent(ref, target, add_new=True)
##  print '  IF4 ', temp_base
  
  temp_reqs = requirements.Copy()
  temp_reqs.ReplaceReferent(ref, target, add_new=False)
  temp_reqs.EliminateResolutions()
  temp_reqs.Simplify()
  
##  print '  IF_RES ', temp_base
##  print '  THEN_RES ', temp_reqs
  mace_result = logic.IsConsistent(temp_base)
##  print '  MACE RESULT:', mace_result
  if not mace_result:
    return False
  prover_result = logic.IsProvable(temp_base, temp_reqs)
##  print '  PROVER RESULT:', prover_result
  return mace_result and prover_result


def ResolveEqualities(root_drs):
  for drs in root_drs.Walk():
    for cond in drs.conditions:
      if isinstance(cond, EqualityCondition):
        if (isinstance(cond.ref1, NamedReferent) and
            isinstance(cond.ref2, NamedReferent)):
          raise ResolutionError('Cannot unify two named entities: %s' % cond)
        ResolveEquality(drs, cond)


def ResolveEquality(root_drs, cond):
  refs = set([cond.ref1, cond.ref2])
  for drs in root_drs.Walk():
    for cond in drs.conditions:
      if isinstance(cond, ResolutionCondition) and cond.ref in refs:
        drs.referents.add(cond.ref)
        drs += cond.requirements
        drs.RemoveCondition(cond)


def ResolveStatement(drs, context):
  return Resolve(drs, context, False)


def ResolveQuestion(drs, context):
  return Resolve(drs, context, True)
